# ---
#
# The following blueprint contains every possible information.
# Note that ids have to be unique, which is not the case below.
#
# Besides that, a general info about storing the values in the graph:
#
# - Metrics are stored with the unit as provided, but the value itself is stored as f64.
#   This allows you to use the metric in this config with another unit as it has been provided.
#   For now, this doesn't make sense (e.g. converting seconds to meters), but their might be upcoming useful use-cases in the future.
# - Note that conversions are executed for resulting values, not for incoming values.
#   So converting a value from `Meters` to `Kilometers`, where the value has originally been provided in `Seconds`, does work.
#   However, the used value will remain being stored in `Seconds`, if the used conversion-command doesn't convert it in-place (replacing it).
#
# ---

# optional
# Reads in a graph and generates further information from the provided ones.
# After generating metrics, the generating-sub-config will be deleted and added to the parsing-config directly.
parsing:
  # relative to user, not to script
  map-file: 'relative-path-to-map-file'
  vehicles:
    category: 'Car' # | 'Bicycle' | 'Pedestrian'
    # Value `false` leads to more edges, because edges are added, which are okay, but not suitable for this vehicle-category.
    are_drivers_picky: false
  # With nodes, the order matters, if the map-file has a order, like `fmi`-files.
  # Behaviour with multiple occurences is undefined, but it probably overwrites previous ones.
  nodes:
  - meta: { info: 'NodeId', id: 'node-id' }
  - meta: { info: 'CHLevel', id: 'ch-level' }
  - metric: { unit: 'Latitude', id: 'latitude' }
  - metric: { unit: 'Longitude', id: 'longitude' }
  - ignored
  edges:
    # optional; default is false, so the graph's edge-metrics aren't being normalized
    will_normalize_metrics_by_mean: false
    # With edges, the order matters, if the map-file has a metric-order, like `fmi`-files.
    # Each metric below will be stored in the graph.
    data:
      # This category can be provided once.
    - meta: { info: 'SrcId', id: 'src-id'}
    - meta: { info: 'DstId', id: 'dst-id'}
      # This category is used for ch-graph and can be provided once.
    - meta: { info: 'ShortcutIdx0', id: 'sc-idx-0'}
    - meta: { info: 'ShortcutIdx1', id: 'sc-idx-1'}
      # This id can be used to import/export matching edge-data.
      # This category can be provided once.
    - meta: { info: 'EdgeId', id: 'edge-id' }
      # metrics, which can be used multiple times (with unique id)
    - metric: { unit: 'Meters', id: 'meters' }
    - metric: { unit: 'Kilometers', id: 'kilometers' }
    - metric: { unit: 'Seconds', id: 'seconds' }
    - metric: { unit: 'Minutes', id: 'minutes' }
    - metric: { unit: 'Hours', id: 'hours' }
    - metric: { unit: 'KilometersPerHour', id: 'kmph' }
    - metric: { unit: 'LaneCount', id: 'lanecount' }
    - metric: { unit: 'F64', id: 'f64' }
    - ignored
  # In case metrics can not be read from the graph directly, they may be generated or added here.
  generating:
    nodes:
      # Register this id, so indices could be used as ids in a new graph-file.
    - meta: { info: 'NodeIdx', id: 'node-idx' }
    - meta: { info: 'CHLevel', id: 'ch-level' }
    edges:
      # This id can be used to import/export matching edge-data
      # This category can be provided once.
    - meta: { info: 'EdgeId', id: 'edge-id' }
      # Register these ids, so indices could be used as ids in a new graph-file.
    - meta: { info: 'SrcIdx', id: 'src-idx' }
    - meta: { info: 'DstIdx', id: 'dst-idx' }
      # Register these ids, e.g. for writing later
    - meta: { info: 'SrcLat', id: 'src-lat' }
    - meta: { info: 'SrcLon', id: 'src-lon' }
    - meta: { info: 'DstLat', id: 'dst-lat' }
    - meta: { info: 'DstLon', id: 'dst-lon' }
      # used for ch-graph, using a default-value, if no shortcut-idx exists yet
    - meta: { info: 'ShortcutIdx0', id: 'sc-idx-0' }
    - meta: { info: 'ShortcutIdx1', id: 'sc-idx-1' }
      # Only distances are allowed, which are generated by the haversine directly.
    - haversine: { unit: 'Kilometers', id: 'kilometers' }
      # Converts from-value out-of-place, so value 'meters' won't be replaced.
    - copy:
        from: { unit: 'Meters', id: 'meters' }
        to: { unit: 'Kilometers', id: 'kilometers' }
      # Converts from-value in-place, so value 'seconds' will be replaced.
    - convert:
        from: { unit: 'Seconds', id: 'seconds' }
        to: { unit: 'Hours', id: 'hours' }
      # Creates a new value, using 'a' and 'b' according to the implementation of the unit of 'result', where 'a' is the first operand (e.g. divide 'a' by 'b').
    - calc:
        result: { unit: 'Minutes', id: 'minutes' }
        a: { unit: 'Kilometers', id: 'kilometers' }
        b: { unit: 'KilometersPerHour', id: 'kmph' }
    - custom:
        unit: 'F64' # optional; default is f64
        id: 'some-value'
        default: 0.0 # optional; default is 0.0
      # Read the edge-data from the provided csv-file and add it to the graph.
    - merge:
        # csv is important, because a header-line is expected
        # and hence removed automatically
        from: 'path/to/csv'
        # optional; default is true
        with_header-line: true
        # this is needed to make parsing easier
        edge-id: 'edge-id'
        # csv-columns
        edges-info:
          # one edge-id has to be provided with the same id as above
        - id: 'edge-id'
        - ignored
          # metrics can only be overwritten
        - id: 'some-value'
# optional
# This config is used for the balancer-binary.
# Pay with the normalization-option.
# Normalizing metrics from a ch-graph makes the shortcuts incorrect,
# because they are calculated with personalized-routing (using alpha-vectors).
balancing:
  # optional; default is 42
  seed: 42
  # optional; default is 4
  number_of_threads: 4
  # every (map-)file is relative to this directory,
  # after this directory was extended by a date
  results-dir: 'custom/results/isle_of_man_2020-03-14'
  iter-0-cfg: 'resources/isle_of_man_2020-03-14/balancing/init.yaml'
  iter-i-cfg: 'resources/isle_of_man_2020-03-14/balancing/iteration.yaml'
  # In the following, multiple optimization-methods are listed.
  # Only one is allowed.
  optimizing_with:
    metric-id: workload
    method:
      # old + (new - old) * correction
      explicit_euler:
        correction: 0.3
      # (iter * old + new) / (iter + 1)
      # Note, that iter is 0 in the first iteration.
      averaging
  # For analysing the new graph, one iteration will be added.
  # -> number_of_metric-updates == 1 implies that 2 iterations will be done.
  # When using averaging as optimization-method, which is recommended,
  # 2 metric-updates are sufficient. More metric-updates worsen the results.
  number_of_metric-updates: 2
  # important to keep non-zero workloads (if generated non-zero):
  # - zero-edges creates more uninteresting shortcuts -> less performance
  # - zero-edges makes Dijkstra running longer/inefficiently
  min_new_metric: 0.1
  multi-ch-constructor:
    fmi-graph: 'graph.fmi'
    contracted-graph: 'graph.ch.fmi'
    # This depends on how many metrics are outsourced to edges-info.csv
    # and includes the new metric as well.
    dimension: 3
    # ignored because replaced by balancer
    minimum-cost: 0.000001
    # ignored because replaced by balancer
    cost-accuracy: 0.000001
    # optional; default is "99.8"
    # This is a string, not a float, because it is provided as cmdline-argument
    contraction-ratio: "99.8"
    # optional; default is 4
    number_of_threads: 4
    # If true, the edge's nodes' osm-ids instead of their indices are used.
    is_printing_osm-ids: false
    # If true, external edge-ids are piped through the multi-ch-constructor.
    is_using_external_edge-ids: false
  # After every metric-update, graph-data is exported for visualization-purpose.
  # If this uses certain graph-data, that has to be generated (e.g. src-lat),
  # this has to be generated in every balancing-config as well!
  # (init.yaml and iteration.yaml)
  monitoring:
    edges-info:
      # see writing: { edges-info: { ... } }
  # optional; default is true
  throw_err_when_new_metric_is_zero: true
# optional; helps with checking balance in binary 'osmgraphing'
evaluating_balance:
  # optional; default is 42
  seed: 42
  results-dir: 'custom/results/isle_of_man_2020-03-14'
  # After every metric-update, graph-data is exported for visualization-purpose.
  # If this uses certain graph-data, that has to be generated (e.g. src-lat),
  # this has to be generated in every balancing-config as well!
  # (init.yaml and iteration.yaml)
  monitoring:
    edges-info:
      # see writing: { edges-info: { ... } }
# optional
# This config can be used with the binary wrapping multi-ch-constructor
multi-ch-constructor:
  fmi-graph: 'path/to/fmi-graph_with_node-indices.fmi'
  contracted-graph: 'path/to/contracted_graph.ch.fmi'
  dimension: 3
  # optional
  cost-accuracy: 0.000001
  # optional; default is "99.8"
  # This is a string, not a float, because it is provided as cmdline-argument
  contraction-ratio: "99.8"
  # optional; default is 4
  number_of_threads: 4
  # If true, the edge's nodes' osm-ids instead of their indices are used.
  is_printing_osm-ids: false
  # If true, external edge-ids are piped through the multi-ch-constructor.
  is_using_external_edge-ids: false
# optional
# The metrics, which should be considered in routing, are listed here.
# The given alphas are used as scale.
# The ch-flag specifies the routing-algorithm.
# It doesn't change correctness, but effects performance positively and
# negatively depending on the provided map.
# It is recommended to set this properly.
routing:
  route-pairs-file: 'relative-path-to-file-containing-route-pairs'
  # Dijkstra, CHDijkstra, Explorator
  algorithm: 'Dijkstra'
  # list of routing-relevant metrics
  metrics:
  - id: 'kilometers'
    # optional; default is 1.0
    alpha: 169.0
    # optional; default is inf
    tolerated-scale: 1.3
  - id: 'minutes'
    # optional; default is 1.0
    alpha: 331.0
# optional
# After parsing and generating the graph, it may be written to an external fmi-file.
# The following lines define the columns of the new fmi-file.
writing:
  # optional
  graph:
    # output-map-file
    map-file: 'relative-path-to-map-file'
    # optional; default is false
    # If false, no shortcuts are written to the file.
    nodes:
    - id: 'node-idx'
    - id: 'latitude'
    - ignored
    - id: 'level'
    - id: 'longitude'
    edges:
      # optional; default is false, meaning
      # if the graph has normalized metrics,
      # it will be printed normalized.
      # If true, metrics will be denormalized before printing.
      will_denormalize_metrics_by_mean: false
      with_shortcuts: false
      ids:
      - id: 'src-id'
      - id: 'dst-idx'
      - ignored
      - id: 'meters'
  edges-info:
    file: 'relative-path-to-map-file'
    # optional; default is false, meaning
    # if the graph has normalized metrics,
    # it will be printed normalized.
    # If true, metrics will be denormalized before printing.
    will_denormalize_metrics_by_mean: false
    with_shortcuts: false
    ids:
    - id: 'edge-id'
    - id: 'src-idx'
    - id: 'dst-idx'
    - ignored
    - id: 'meters'
  # optional
  route-pairs:
    file: 'relative-path-to-output-file'
    # In the following, several modes are listed.
    # Only one is allowed.
    #
    # This mode generates random routes, if the graph has more than max_count possible routes (`node_count * node_count > max_count`).
    # If the number of possible routes is less, simply all existing routes of the graph are printed.
    random_or_all:
      # optional
      seed: 42
      max_count: 100
